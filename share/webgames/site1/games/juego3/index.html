<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>To the Moon</title>
  <style>
    :root {
      --bg0: #040b1e;
      --bg1: #10234c;
      --ink: #e4efff;
      --muted: #9ec2f2;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      color: var(--ink);
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      background:
        radial-gradient(1100px 700px at 15% 10%, #1a3d80 0%, transparent 56%),
        radial-gradient(980px 640px at 82% 94%, #133666 0%, transparent 56%),
        linear-gradient(160deg, var(--bg0), var(--bg1));
    }
    .wrap {
      width: min(100vw - 20px, 1040px);
      display: grid;
      gap: 10px;
      justify-items: center;
    }
    canvas {
      width: 100%;
      max-width: 1000px;
      aspect-ratio: 16 / 9;
      border: 1px solid #7aa7e3;
      border-radius: 12px;
      background: #060f20;
      box-shadow: 0 20px 66px rgba(0, 0, 0, 0.5);
      touch-action: none;
    }
    .hint {
      font-size: 13px;
      color: var(--muted);
      text-align: center;
      line-height: 1.45;
    }
    a { color: #d6e7ff; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="1000" height="560" aria-label="To the Moon"></canvas>
    <div class="hint">To the Moon: scroll vertical tipo shooter. Mover con WASD/flechas, disparar con Espacio/J, R reinicia, F fullscreen. <a href="/g">Volver</a></div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const W = canvas.width;
      const H = canvas.height;

      const keys = new Set();
      const alias = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down",
        a: "left",
        d: "right",
        w: "up",
        s: "down",
        j: "shoot",
        " ": "shoot",
      };

      const stars = Array.from({ length: 180 }, () => ({
        x: Math.random() * W,
        y: Math.random() * H,
        z: 0.2 + Math.random() * 1.5,
      }));

      const state = {
        title: "To the Moon",
        mode: "menu",
        msg: "Pulsa ENTER para despegar",
        tick: 0,
        distance: 0,
        score: 0,
        spawnT: 0,
        player: {
          x: W / 2,
          y: H - 80,
          w: 32,
          h: 26,
          speed: 320,
          hp: 5,
          cooldown: 0,
          inv: 0,
        },
        bullets: [],
        enemies: [],
        particles: [],
      };

      function resetGame() {
        state.mode = "playing";
        state.msg = "Subiendo hacia la luna";
        state.tick = 0;
        state.distance = 0;
        state.score = 0;
        state.spawnT = 0;
        state.player.x = W / 2;
        state.player.y = H - 80;
        state.player.hp = 5;
        state.player.cooldown = 0;
        state.player.inv = 0;
        state.bullets = [];
        state.enemies = [];
        state.particles = [];
      }

      function hit(a, b) {
        return (
          Math.abs(a.x - b.x) * 2 < (a.w + b.w) &&
          Math.abs(a.y - b.y) * 2 < (a.h + b.h)
        );
      }

      function burst(x, y, color, amount) {
        for (let i = 0; i < amount; i += 1) {
          const a = Math.random() * Math.PI * 2;
          const s = 30 + Math.random() * 150;
          state.particles.push({
            x,
            y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            t: 0.25 + Math.random() * 0.45,
            c: color,
          });
        }
      }

      function spawnEnemy() {
        const edge = 20;
        const x = edge + Math.random() * (W - edge * 2);
        const scale = 0.8 + Math.random() * 0.5;
        const hp = 1 + Math.floor(state.distance / 2000);
        state.enemies.push({
          x,
          y: -40,
          w: 30 * scale,
          h: 24 * scale,
          hp,
          vy: 70 + Math.random() * 90 + state.distance * 0.01,
          sway: Math.random() * Math.PI * 2,
        });
      }

      function damagePlayer() {
        if (state.player.inv > 0) return;
        state.player.hp -= 1;
        state.player.inv = 1.1;
        burst(state.player.x, state.player.y, "#fb7185", 20);
        if (state.player.hp <= 0) {
          state.mode = "gameover";
          state.msg = "Te quedaste sin casco. Pulsa R para reintentar";
        }
      }

      function update(dt) {
        state.tick += dt;

        const scroll = 90 + Math.min(220, state.distance * 0.02);
        for (const s of stars) {
          s.y += scroll * s.z * dt;
          if (s.y > H + 2) {
            s.y = -2;
            s.x = Math.random() * W;
          }
        }

        if (state.mode !== "playing") return;

        state.distance += scroll * dt;
        state.spawnT -= dt;

        const player = state.player;
        let dx = 0;
        let dy = 0;
        if (keys.has("left")) dx -= 1;
        if (keys.has("right")) dx += 1;
        if (keys.has("up")) dy -= 1;
        if (keys.has("down")) dy += 1;
        const mag = Math.hypot(dx, dy) || 1;
        player.x += (dx / mag) * player.speed * dt;
        player.y += (dy / mag) * player.speed * dt;

        player.x = Math.max(20, Math.min(W - 20, player.x));
        player.y = Math.max(H * 0.4, Math.min(H - 20, player.y));

        player.cooldown -= dt;
        player.inv = Math.max(0, player.inv - dt);

        if (keys.has("shoot") && player.cooldown <= 0) {
          state.bullets.push({ x: player.x, y: player.y - 16, vx: 0, vy: -580, w: 6, h: 12 });
          player.cooldown = 0.13;
        }

        if (state.spawnT <= 0) {
          spawnEnemy();
          const spawnRate = Math.max(0.2, 0.9 - state.distance * 0.00025);
          state.spawnT = spawnRate;
        }

        for (const b of state.bullets) {
          b.x += b.vx * dt;
          b.y += b.vy * dt;
        }
        state.bullets = state.bullets.filter((b) => b.y > -40);

        for (const e of state.enemies) {
          e.y += e.vy * dt;
          e.x += Math.sin(state.tick * 3 + e.sway) * 38 * dt;
        }

        for (const e of state.enemies) {
          if (e.y > H + 24) {
            e.hp = -999;
            damagePlayer();
          }

          if (hit(e, player)) {
            e.hp = -999;
            damagePlayer();
            burst(e.x, e.y, "#f59e0b", 18);
          }
        }

        for (const b of state.bullets) {
          for (const e of state.enemies) {
            if (e.hp <= 0) continue;
            if (Math.abs(b.x - e.x) < e.w * 0.5 && Math.abs(b.y - e.y) < e.h * 0.5) {
              b.y = -100;
              e.hp -= 1;
              if (e.hp <= 0) {
                state.score += 10;
                burst(e.x, e.y, "#7dd3fc", 14);
              }
              break;
            }
          }
        }

        state.bullets = state.bullets.filter((b) => b.y > -50);
        state.enemies = state.enemies.filter((e) => e.hp > 0 && e.y < H + 60);

        for (const p of state.particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.t -= dt;
        }
        state.particles = state.particles.filter((p) => p.t > 0);
      }

      function drawShip(x, y, color, scale = 1, flipped = false) {
        const w = 24 * scale;
        const h = 30 * scale;
        ctx.save();
        ctx.translate(x, y);
        if (flipped) ctx.rotate(Math.PI);

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(0, -h * 0.55);
        ctx.lineTo(w * 0.45, h * 0.42);
        ctx.lineTo(0, h * 0.18);
        ctx.lineTo(-w * 0.45, h * 0.42);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.35)";
        ctx.fillRect(-3 * scale, -h * 0.2, 6 * scale, h * 0.4);

        ctx.restore();
      }

      function draw() {
        const bg = ctx.createLinearGradient(0, 0, 0, H);
        bg.addColorStop(0, "#060f23");
        bg.addColorStop(1, "#0c1a35");
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);

        for (const s of stars) {
          const c = 180 + Math.floor(s.z * 50);
          ctx.fillStyle = `rgb(${c},${c},255)`;
          const size = 1 + s.z * 1.8;
          ctx.fillRect(s.x, s.y, size, size);
        }

        ctx.fillStyle = "rgba(6, 13, 28, 0.85)";
        ctx.fillRect(20, 16, W - 40, 62);
        ctx.strokeStyle = "rgba(158, 194, 242, 0.6)";
        ctx.strokeRect(20, 16, W - 40, 62);

        ctx.fillStyle = "#eef5ff";
        ctx.font = "bold 30px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillText("TO THE MOON", 36, 53);

        ctx.font = "bold 17px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillStyle = "#bad5f8";
        ctx.fillText(`Distancia: ${Math.floor(state.distance)}m`, 330, 42);
        ctx.fillText(`Score: ${state.score}`, 330, 66);
        ctx.fillText(`HP: ${state.player.hp}`, 560, 42);
        ctx.fillText(`Enemigos: ${state.enemies.length}`, 560, 66);

        for (const b of state.bullets) {
          ctx.fillStyle = "#f8fafc";
          ctx.fillRect(b.x - 2, b.y - 10, 4, 12);
        }

        for (const e of state.enemies) {
          drawShip(e.x, e.y, "#f59e0b", Math.max(0.7, e.w / 30), true);
        }

        const blink = state.player.inv > 0 && Math.floor(state.tick * 20) % 2 === 0;
        if (!blink || state.mode !== "playing") drawShip(state.player.x, state.player.y, "#34d399", 1, false);

        for (const p of state.particles) {
          ctx.globalAlpha = Math.max(0, p.t * 2);
          ctx.fillStyle = p.c;
          ctx.fillRect(p.x, p.y, 3, 3);
        }
        ctx.globalAlpha = 1;

        ctx.fillStyle = "rgba(7, 15, 31, 0.9)";
        ctx.fillRect(26, H - 36, W - 52, 22);
        ctx.strokeStyle = "rgba(157, 195, 243, 0.35)";
        ctx.strokeRect(26, H - 36, W - 52, 22);
        ctx.fillStyle = "#d7e9ff";
        ctx.font = "bold 14px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillText(state.msg, 36, H - 21);

        if (state.mode === "menu") {
          ctx.fillStyle = "rgba(8, 14, 28, 0.62)";
          ctx.fillRect(0, 0, W, H);
          ctx.fillStyle = "rgba(16, 29, 58, 0.96)";
          ctx.fillRect(210, 194, W - 420, 180);
          ctx.strokeStyle = "rgba(164, 200, 243, 0.72)";
          ctx.strokeRect(210, 194, W - 420, 180);
          ctx.textAlign = "center";
          ctx.fillStyle = "#edf5ff";
          ctx.font = "bold 46px Trebuchet MS, Segoe UI, sans-serif";
          ctx.fillText("TO THE MOON", W / 2, 254);
          ctx.font = "20px Trebuchet MS, Segoe UI, sans-serif";
          ctx.fillText("Vertical scroll shooter inspirado en Jamestown", W / 2, 300);
          ctx.fillText("ENTER para despegar", W / 2, 332);
          ctx.textAlign = "start";
        }

        if (state.mode === "gameover") {
          ctx.fillStyle = "rgba(8, 14, 28, 0.5)";
          ctx.fillRect(0, 0, W, H);
        }
      }

      function gameToText() {
        return JSON.stringify({
          title: state.title,
          coordinateSystem: "lienzo 1000x560 con origen arriba-izquierda",
          mode: state.mode,
          distanceMeters: Math.floor(state.distance),
          score: state.score,
          message: state.msg,
          player: {
            x: Number(state.player.x.toFixed(1)),
            y: Number(state.player.y.toFixed(1)),
            hp: state.player.hp,
            cooldown: Number(Math.max(0, state.player.cooldown).toFixed(2)),
          },
          enemies: state.enemies.slice(0, 12).map((e) => ({
            x: Number(e.x.toFixed(1)),
            y: Number(e.y.toFixed(1)),
            hp: e.hp,
          })),
          bullets: state.bullets.slice(0, 12).map((b) => ({
            x: Number(b.x.toFixed(1)),
            y: Number(b.y.toFixed(1)),
          })),
        });
      }

      function advanceBy(ms) {
        const dt = 1 / 60;
        const steps = Math.max(1, Math.round(ms / (1000 / 60)));
        for (let i = 0; i < steps; i += 1) update(dt);
        draw();
      }

      function toggleFullscreen() {
        if (!document.fullscreenElement) canvas.requestFullscreen().catch(() => {});
        else document.exitFullscreen().catch(() => {});
      }

      window.addEventListener("keydown", (ev) => {
        const raw = ev.key.length === 1 ? ev.key.toLowerCase() : ev.key;
        const mapped = alias[raw] || null;
        if (mapped) keys.add(mapped);

        if (raw === "Enter" && state.mode !== "playing") resetGame();
        if (raw === "r") resetGame();
        if (raw === "f") toggleFullscreen();
      });

      window.addEventListener("keyup", (ev) => {
        const raw = ev.key.length === 1 ? ev.key.toLowerCase() : ev.key;
        const mapped = alias[raw] || null;
        if (mapped) keys.delete(mapped);
      });

      let last = 0;
      function loop(ts) {
        const dt = Math.min(0.05, (ts - last) / 1000 || 1 / 60);
        last = ts;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      window.render_game_to_text = gameToText;
      window.advanceTime = advanceBy;

      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
