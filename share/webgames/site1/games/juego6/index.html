<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hex Survivors</title>
  <style>
    :root {
      --bg0: #0a1a16;
      --bg1: #143126;
      --ink: #e8fff4;
      --muted: #afe5cd;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      color: var(--ink);
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      background:
        radial-gradient(960px 680px at 12% 12%, #255c48 0%, transparent 62%),
        radial-gradient(980px 660px at 86% 88%, #1a3f32 0%, transparent 62%),
        linear-gradient(160deg, var(--bg0), var(--bg1));
    }
    .wrap {
      width: min(100vw - 20px, 1060px);
      display: grid;
      gap: 10px;
      justify-items: center;
    }
    canvas {
      width: 100%;
      max-width: 1020px;
      aspect-ratio: 16 / 10;
      border: 1px solid #8fceaf;
      border-radius: 12px;
      background: #08150f;
      box-shadow: 0 20px 68px rgba(0, 0, 0, 0.52);
      touch-action: none;
    }
    .hint {
      font-size: 13px;
      color: var(--muted);
      text-align: center;
      line-height: 1.45;
    }
    a { color: #d8ffec; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="1020" height="640" aria-label="Hex Survivors"></canvas>
    <div class="hint">Camara cenital tipo Vampire Survivors: mueve con WASD/flechas, ataques automaticos y mejoras de poder por nivel. R reinicia, F fullscreen. <a href="/g">Volver</a></div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const W = canvas.width;
      const H = canvas.height;

      const keys = new Set();
      const alias = {
        ArrowLeft: "left",
        ArrowRight: "right",
        ArrowUp: "up",
        ArrowDown: "down",
        a: "left",
        d: "right",
        w: "up",
        s: "down",
      };

      const state = {
        title: "Hex Survivors",
        mode: "menu",
        msg: "Pulsa ENTER para sobrevivir",
        tick: 0,
        time: 0,
        score: 0,
        spawnT: 0,
        level: 1,
        xp: 0,
        xpNeed: 12,
        player: {
          x: 0,
          y: 0,
          r: 14,
          hp: 100,
          maxHp: 100,
          speed: 210,
          fireCooldown: 0,
          fireRate: 0.5,
          damage: 1,
          inv: 0,
        },
        enemies: [],
        bolts: [],
        gems: [],
        particles: [],
      };

      function resetGame() {
        state.mode = "playing";
        state.msg = "Sobrevive y mejora poderes";
        state.tick = 0;
        state.time = 0;
        state.score = 0;
        state.spawnT = 0.3;
        state.level = 1;
        state.xp = 0;
        state.xpNeed = 12;
        state.player.x = 0;
        state.player.y = 0;
        state.player.hp = 100;
        state.player.maxHp = 100;
        state.player.speed = 210;
        state.player.fireCooldown = 0;
        state.player.fireRate = 0.5;
        state.player.damage = 1;
        state.player.inv = 0;
        state.enemies = [];
        state.bolts = [];
        state.gems = [];
        state.particles = [];
      }

      function worldToScreen(wx, wy) {
        return {
          x: wx - state.player.x + W / 2,
          y: wy - state.player.y + H / 2,
        };
      }

      function burst(x, y, color, amount) {
        for (let i = 0; i < amount; i += 1) {
          const a = Math.random() * Math.PI * 2;
          const s = 35 + Math.random() * 180;
          state.particles.push({
            x,
            y,
            vx: Math.cos(a) * s,
            vy: Math.sin(a) * s,
            t: 0.2 + Math.random() * 0.5,
            c: color,
          });
        }
      }

      function nearestEnemy() {
        let best = null;
        let bestD = Infinity;
        for (const e of state.enemies) {
          const dx = e.x - state.player.x;
          const dy = e.y - state.player.y;
          const d = dx * dx + dy * dy;
          if (d < bestD) {
            bestD = d;
            best = e;
          }
        }
        return best;
      }

      function spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 360 + Math.random() * 140;
        const hp = 2 + Math.floor(state.time / 35);
        const speed = 55 + Math.min(90, state.time * 1.2) + Math.random() * 20;
        state.enemies.push({
          x: state.player.x + Math.cos(angle) * dist,
          y: state.player.y + Math.sin(angle) * dist,
          r: 12,
          hp,
          speed,
          touchCd: 0,
        });
      }

      function gainXp(v) {
        state.xp += v;
        while (state.xp >= state.xpNeed) {
          state.xp -= state.xpNeed;
          state.level += 1;
          state.xpNeed = Math.floor(state.xpNeed * 1.35 + 6);
          applyUpgrade();
        }
      }

      function applyUpgrade() {
        const pick = state.level % 4;
        if (pick === 0) {
          state.player.damage += 1;
          state.msg = "Poder: +1 dano";
        } else if (pick === 1) {
          state.player.fireRate = Math.max(0.18, state.player.fireRate - 0.05);
          state.msg = "Poder: mayor cadencia";
        } else if (pick === 2) {
          state.player.speed += 16;
          state.msg = "Poder: +velocidad";
        } else {
          state.player.maxHp += 12;
          state.player.hp = Math.min(state.player.maxHp, state.player.hp + 10);
          state.msg = "Poder: vitalidad extra";
        }
      }

      function damagePlayer(amount) {
        if (state.player.inv > 0) return;
        state.player.hp -= amount;
        state.player.inv = 0.45;
        burst(state.player.x, state.player.y, "#fb7185", 18);
        if (state.player.hp <= 0) {
          state.mode = "gameover";
          state.msg = "Te rodearon. Pulsa R para reintentar";
        }
      }

      function update(dt) {
        state.tick += dt;

        for (const p of state.particles) {
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.t -= dt;
        }
        state.particles = state.particles.filter((p) => p.t > 0);

        if (state.mode !== "playing") return;

        state.time += dt;
        state.score = Math.floor(state.time * 10 + state.level * 50);

        let dx = 0;
        let dy = 0;
        if (keys.has("left")) dx -= 1;
        if (keys.has("right")) dx += 1;
        if (keys.has("up")) dy -= 1;
        if (keys.has("down")) dy += 1;
        const mag = Math.hypot(dx, dy) || 1;
        state.player.x += (dx / mag) * state.player.speed * dt;
        state.player.y += (dy / mag) * state.player.speed * dt;

        state.player.inv = Math.max(0, state.player.inv - dt);

        state.spawnT -= dt;
        if (state.spawnT <= 0) {
          spawnEnemy();
          const spawnRate = Math.max(0.15, 0.75 - state.time * 0.012);
          state.spawnT = spawnRate;
        }

        state.player.fireCooldown -= dt;
        if (state.player.fireCooldown <= 0 && state.enemies.length > 0) {
          const t = nearestEnemy();
          if (t) {
            const ax = t.x - state.player.x;
            const ay = t.y - state.player.y;
            const len = Math.hypot(ax, ay) || 1;
            const speed = 440;
            state.bolts.push({
              x: state.player.x,
              y: state.player.y,
              vx: (ax / len) * speed,
              vy: (ay / len) * speed,
              life: 1.1,
              damage: state.player.damage,
            });
            state.player.fireCooldown = state.player.fireRate;
          }
        }

        for (const b of state.bolts) {
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
        }
        state.bolts = state.bolts.filter((b) => b.life > 0);

        for (const e of state.enemies) {
          const ax = state.player.x - e.x;
          const ay = state.player.y - e.y;
          const len = Math.hypot(ax, ay) || 1;
          e.x += (ax / len) * e.speed * dt;
          e.y += (ay / len) * e.speed * dt;
          e.touchCd = Math.max(0, e.touchCd - dt);

          const pd = Math.hypot(e.x - state.player.x, e.y - state.player.y);
          if (pd < e.r + state.player.r && e.touchCd <= 0) {
            damagePlayer(8);
            e.touchCd = 0.4;
          }
        }

        for (const b of state.bolts) {
          for (const e of state.enemies) {
            if (e.hp <= 0) continue;
            const d = Math.hypot(b.x - e.x, b.y - e.y);
            if (d < e.r + 4) {
              e.hp -= b.damage;
              b.life = -1;
              burst(e.x, e.y, "#67e8f9", 8);
              if (e.hp <= 0) {
                state.gems.push({ x: e.x, y: e.y, v: 3 + Math.floor(state.time / 30) });
                burst(e.x, e.y, "#86efac", 14);
              }
              break;
            }
          }
        }

        state.bolts = state.bolts.filter((b) => b.life > 0);
        state.enemies = state.enemies.filter((e) => e.hp > 0);

        for (const g of state.gems) {
          const d = Math.hypot(g.x - state.player.x, g.y - state.player.y);
          if (d < 140) {
            const pull = 90 + (140 - d) * 3;
            const ax = (state.player.x - g.x) / (d || 1);
            const ay = (state.player.y - g.y) / (d || 1);
            g.x += ax * pull * dt;
            g.y += ay * pull * dt;
          }
        }

        const keep = [];
        for (const g of state.gems) {
          const d = Math.hypot(g.x - state.player.x, g.y - state.player.y);
          if (d < state.player.r + 10) {
            gainXp(g.v);
          } else {
            keep.push(g);
          }
        }
        state.gems = keep;
      }

      function drawGrid() {
        const left = state.player.x - W / 2;
        const top = state.player.y - H / 2;
        const step = 56;

        ctx.strokeStyle = "rgba(144, 211, 178, 0.12)";
        ctx.lineWidth = 1;

        const startX = Math.floor(left / step) * step;
        const endX = left + W + step;
        for (let x = startX; x <= endX; x += step) {
          const sx = x - left;
          ctx.beginPath();
          ctx.moveTo(sx, 0);
          ctx.lineTo(sx, H);
          ctx.stroke();
        }

        const startY = Math.floor(top / step) * step;
        const endY = top + H + step;
        for (let y = startY; y <= endY; y += step) {
          const sy = y - top;
          ctx.beginPath();
          ctx.moveTo(0, sy);
          ctx.lineTo(W, sy);
          ctx.stroke();
        }
      }

      function draw() {
        const bg = ctx.createLinearGradient(0, 0, 0, H);
        bg.addColorStop(0, "#0a1812");
        bg.addColorStop(1, "#09140f");
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, W, H);

        drawGrid();

        ctx.fillStyle = "rgba(9, 23, 18, 0.86)";
        ctx.fillRect(20, 16, W - 40, 70);
        ctx.strokeStyle = "rgba(153, 215, 185, 0.6)";
        ctx.strokeRect(20, 16, W - 40, 70);

        ctx.fillStyle = "#ecfff5";
        ctx.font = "bold 31px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillText("HEX SURVIVORS", 38, 54);

        ctx.font = "bold 17px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillStyle = "#c6f0dc";
        ctx.fillText(`Tiempo: ${state.time.toFixed(1)}s`, 330, 44);
        ctx.fillText(`Nivel: ${state.level}`, 330, 68);
        ctx.fillText(`HP: ${Math.max(0, Math.floor(state.player.hp))}/${state.player.maxHp}`, 510, 44);
        ctx.fillText(`XP: ${state.xp}/${state.xpNeed}`, 510, 68);
        ctx.fillText(`Puntaje: ${state.score}`, 720, 44);
        ctx.fillText(`Enemigos: ${state.enemies.length}`, 720, 68);

        for (const g of state.gems) {
          const p = worldToScreen(g.x, g.y);
          ctx.fillStyle = "#34d399";
          ctx.beginPath();
          ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }

        for (const e of state.enemies) {
          const p = worldToScreen(e.x, e.y);
          ctx.fillStyle = "#ef4444";
          ctx.beginPath();
          ctx.arc(p.x, p.y, e.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "rgba(255,255,255,0.25)";
          ctx.fillRect(p.x - e.r * 0.6, p.y - 2, e.r * 1.2, 4);
        }

        for (const b of state.bolts) {
          const p = worldToScreen(b.x, b.y);
          ctx.fillStyle = "#93c5fd";
          ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
        }

        const pp = worldToScreen(state.player.x, state.player.y);
        const blink = state.player.inv > 0 && Math.floor(state.tick * 16) % 2 === 0;
        if (!blink || state.mode !== "playing") {
          ctx.fillStyle = "#22c55e";
          ctx.beginPath();
          ctx.arc(pp.x, pp.y, state.player.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = "#052e16";
          ctx.fillRect(pp.x - 6, pp.y - 6, 12, 12);
        }

        for (const p of state.particles) {
          const s = worldToScreen(p.x, p.y);
          ctx.globalAlpha = Math.max(0, p.t * 2);
          ctx.fillStyle = p.c;
          ctx.fillRect(s.x, s.y, 3, 3);
        }
        ctx.globalAlpha = 1;

        ctx.fillStyle = "rgba(7, 17, 13, 0.9)";
        ctx.fillRect(22, H - 36, W - 44, 22);
        ctx.strokeStyle = "rgba(153, 215, 185, 0.35)";
        ctx.strokeRect(22, H - 36, W - 44, 22);
        ctx.fillStyle = "#dff9ec";
        ctx.font = "bold 14px Trebuchet MS, Segoe UI, sans-serif";
        ctx.fillText(state.msg, 32, H - 20);

        if (state.mode === "menu") {
          ctx.fillStyle = "rgba(9, 20, 15, 0.62)";
          ctx.fillRect(0, 0, W, H);
          ctx.fillStyle = "rgba(13, 33, 25, 0.96)";
          ctx.fillRect(190, 220, W - 380, 182);
          ctx.strokeStyle = "rgba(154, 215, 186, 0.72)";
          ctx.strokeRect(190, 220, W - 380, 182);
          ctx.textAlign = "center";
          ctx.fillStyle = "#effff7";
          ctx.font = "bold 44px Trebuchet MS, Segoe UI, sans-serif";
          ctx.fillText("HEX SURVIVORS", W / 2, 280);
          ctx.font = "20px Trebuchet MS, Segoe UI, sans-serif";
          ctx.fillText("Camara cenital con poderes y hordas", W / 2, 324);
          ctx.fillText("ENTER para empezar", W / 2, 356);
          ctx.textAlign = "start";
        }

        if (state.mode === "gameover") {
          ctx.fillStyle = "rgba(9, 20, 15, 0.52)";
          ctx.fillRect(0, 0, W, H);
        }
      }

      function gameToText() {
        return JSON.stringify({
          title: state.title,
          coordinateSystem: "mundo continuo 2D con camara centrada en el jugador",
          mode: state.mode,
          timeSec: Number(state.time.toFixed(2)),
          score: state.score,
          level: state.level,
          xp: state.xp,
          xpNeed: state.xpNeed,
          player: {
            x: Number(state.player.x.toFixed(1)),
            y: Number(state.player.y.toFixed(1)),
            hp: Number(state.player.hp.toFixed(1)),
            maxHp: state.player.maxHp,
            speed: state.player.speed,
            damage: state.player.damage,
            fireRate: Number(state.player.fireRate.toFixed(2)),
          },
          enemies: state.enemies.slice(0, 14).map((e) => ({
            x: Number(e.x.toFixed(1)),
            y: Number(e.y.toFixed(1)),
            hp: e.hp,
          })),
          gems: state.gems.slice(0, 14).map((g) => ({
            x: Number(g.x.toFixed(1)),
            y: Number(g.y.toFixed(1)),
            v: g.v,
          })),
          message: state.msg,
        });
      }

      function advanceBy(ms) {
        const dt = 1 / 60;
        const steps = Math.max(1, Math.round(ms / (1000 / 60)));
        for (let i = 0; i < steps; i += 1) update(dt);
        draw();
      }

      function toggleFullscreen() {
        if (!document.fullscreenElement) canvas.requestFullscreen().catch(() => {});
        else document.exitFullscreen().catch(() => {});
      }

      window.addEventListener("keydown", (ev) => {
        const raw = ev.key.length === 1 ? ev.key.toLowerCase() : ev.key;
        const mapped = alias[raw] || null;
        if (mapped) keys.add(mapped);

        if (raw === "Enter" && state.mode !== "playing") resetGame();
        if (raw === "r") resetGame();
        if (raw === "f") toggleFullscreen();
      });

      window.addEventListener("keyup", (ev) => {
        const raw = ev.key.length === 1 ? ev.key.toLowerCase() : ev.key;
        const mapped = alias[raw] || null;
        if (mapped) keys.delete(mapped);
      });

      let last = 0;
      function loop(ts) {
        const dt = Math.min(0.05, (ts - last) / 1000 || 1 / 60);
        last = ts;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      window.render_game_to_text = gameToText;
      window.advanceTime = advanceBy;

      draw();
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
